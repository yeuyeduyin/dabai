jvm内存模型:  
1.程序计数器  不是线程共享，每个线程都有一个程序计数器，记录当前线程执行程序的位置，用来循环、分支、方法跳转、异常处理、线程恢复。

2.java虚拟机栈（VM Stack） 不是线程共享，每个线程创建时都会创建一个虚拟机栈，每个方法都会创建一个栈帧存放在虚拟机栈，栈帧分为：局部变量表、操作数栈、动态连接、方法出口。
一个web请求就会生产一个新线程，线程多了，并发量大会导致内存溢出（OutOfMemoneyError），这时可以调整虚拟机栈的大小，可以容纳更多线程，但是虚拟机栈变小，如果方法调用深度过深栈空间不够会导致栈内存溢出（StackOverFlowError）。

3.本地方法栈（Native Method Stack）
不是线程共享，为虚拟机使用到本地方法服务（native），与虚拟机栈类似，调用本地方法时，存储本地方法的局部变量操作数栈（后进先出或表达式栈出入栈操作）

4.堆（Heap） 是线程共享的，所有线程共享一个堆，在虚拟机启动时创建。堆里存放的都是对象的实例（new出来的对象都放在堆中），垃圾回收（gc）主要就是回收堆区。为了提高回收性能，把堆分成两块区：新生代（yong）和老年代（old），新生代又可细分成：Eden区：存放新创建的对象、Form Survivor和To Survivor（两个Survivor）：保存新生代gc后还存活的对象。老年代：对象存活时间比较长（经过多次新生代gc，默认15次）的对象。
当堆中分配的对象实例过多，且大部分在使用，就会报内存溢出异常（OutOfMemoneyError）。

5.方法区  是线程共享的，用于存放已被虚拟机加载的类信息，常量，静态变量等数据。被虚拟机描述为堆的一个逻辑部分。习惯也叫永久代（PermGen），也会垃圾回收，主要针对常量池回收，类型卸载（反射生成的大量的临时使用的Class等信息）。常量池用于存放编译期生产的各种字节码和符号的引用，当方法区满时，无法在分配空间，就会抛出内存溢出的异常（OutOfMemoneyError），jdk8已经没有方法区了，取而代之的是元空间（Metaspace）

6.直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。
????JDK1.4加的NIO中，ByteBuffer有个方法是allocateDirect(int capacity) ，这是一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。


 